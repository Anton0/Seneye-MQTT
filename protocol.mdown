# SUD Protocol
This is an attempt to describe the SUD protocol based on reading the main.cpp file that Seneye released.

## USB device
### Transfers
The SUD device seems to have these 2 types of USB transfers available: interrupt and bulk. HID devices only use 2 transfer modes of either control or interrupt.

### Endpoints
Max packet size is 64 bytes for all endpoints.
From printing the configuration these are the endpoints:
- ENDPOINT 0x81: Interrupt IN
- ENDPOINT 0x1: Interrupt OUT
- ENDPOINT 0x82: Bulk IN
- ENDPOINT 0x2: Bulk OUT

Apparently HID devices do not use the 'bulk' interface, so only the 'interrupt' interface is used.
This comes from https://en.wikipedia.org/wiki/USB_human_interface_device_class

USB devices have a hierarchy of interfaces, like so:
1. Device
1. Configuration
1. Interface
1. Alternate setting
1. Endpoint

## Protocol
### Protocol flow
From what I have been able to determine from the C++ module that Seneye released, the flow goes a little like this: once you have obtained correct access to the device via USB handlers, you start by sending the "HELLOSUD" message and receive a version message in response. You then ask for the sensor values using a message "READING", and get back a return code if the command was accepted. You then read the next message (no command) with a longer timeout and get the sensor values. At the end you then send a "BYESUD" closing message to stop communication and close down the USB handlers as appropriate. The command to switch on or off the LEDs is similar.


### Protocol messages
There are command type messages, and response messages with readings from the device.
* Command: Communication starts with a message "HELLOSUD".
* Command: Request sensor parameters with a "READING" message.
* Command: Turn off or on LEDS with a "LED" message.
* Command: Communcation ends with a "BYESUD" message
* Response: from "HELLOSUD"
	- byte 1: eyecatcher value = 0x88
	- byte 2: '0x01'='HELLOSUD', '0x02'='READING', '0x03'='LED'
	- byte 3: '1'=success, otherwise=failure
	- byte 4: the type of the device, 0/1=home, 2=pond, 3=reef
	- byte 5: device version byte 1
	- byte 6: device version byte 2, version is x.x.x
* Response: from "READING"
	- byte 1: eyecatcher value = 0x00
	- byte 2: '0x01'=reading, '0x02'=lightmeter reading

### Protocol table
#### Outgoing to SUD

| Byte 1 | Byte 2 | Byte 3 | Byte 4 | Byte 5 | Byte 6 | Byte 7 | Byte 8 | Description |
|---|---|---|---|---|---|---|---|---|
|H|E|L|L|O|S|U|D|Start comms|
|R|E|A|D|I|N|G||READING|
|L|E|D||||||LED|
|B|Y|E|S|U|D|||End comms|

#### Incoming from SUD

| Byte 1 | Byte 2 | Byte 3 | Byte 4 | Byte 5 | Byte 6 | Byte 7 | Byte 8 | Description |
|---|---|---|---|---|---|---|---|---|
|0x88|0x01|||||||Response from HELLOSUD|
|0x88|0x02|1||||||Response from READING|
|0x88|0x03|1||||||Response from LED|
|0x00|0x01|||||||Reading|
|0x00|0x02|||||||Lightmeter reading|



# How you can help
At least this is what I think happens from my reading of the code, if anyone would like to read the Seneye main.cpp module and edit to correct then please do. To do that, fork the code repo, edit, push and send me a new pull request, thanks!