# SUD Protocol
This is an attempt to describe the SUD protocol based on reading the main.cpp file that Seneye released.

## USB device
### Transfers
The SUD device seems to have these 2 types of USB transfers available: interrupt and bulk. HID devices only use 2 transfer modes of either control or interrupt.

### Endpoints
Max packet size is 64 bytes for all endpoints.
From printing the configuration these are the endpoints:
- ENDPOINT 0x81: Interrupt IN
- ENDPOINT 0x1: Interrupt OUT
- ENDPOINT 0x82: Bulk IN
- ENDPOINT 0x2: Bulk OUT

Apparently HID devices do not use the 'bulk' interface, so only the 'interrupt' interface is used.
This comes from https://en.wikipedia.org/wiki/USB_human_interface_device_class

USB devices have a hierarchy of interfaces, like so:
1. Device
1. Configuration
1. Interface
1. Alternate setting
1. Endpoint

## Protocol messages
1. Type 1: Communication starts with a message "HELLOSUD".
1. Type 2:
	- byte 1: eyecatcher value = 0x88
	- byte 2: '0x01'='HELLOSUD', '0x02'='READING', '0x03'='LED'
	- byte 3: '1'=success, otherwise=failure
	- byte 4: the type of the device, 0/1=home, 2=pond, 3=reef
	- byte 5: device version byte 1
	- byte 6: device version byte 2, version is x.x.x
1. Type 3:
	- byte 1: eyecatcher value = 0x00
	- byte 2: '0x01'=reading, '0x02'=lightmeter reading
1. Type 4: Communcation ends with a "BYESUD" message

## Protocol table

| Type | Byte 1 | Byte 2 | Byte 3 | Byte 4 | Byte 5 | Byte 6 | Byte 7 | Byte 8 | Description |
|---|---|---|---|---|---|---|---|---|---|
|1|H|E|L|L|O|S|U|D|Start comms|
|2|0x88|0x01|||||||Response from HELLOSUD|
|2|0x88|0x02|1||||||READING|
|2|0x88|0x03|1||||||LED|
|3|0x00|0x01|||||||Reading|
|3|0x00|0x02|||||||Lightmeter reading|
|4|B|Y|E|S|U|D|||End comms|

## Protocol flow
From what I have been able to determine from the C++ module that Seneye released, the flow goes a little like this: once you have obtained correct access to the device via USB handlers, you start by sending the "HELLOSUD" message and receive a version message in response. You then ask for the sensor values using a message "READING", and get back the sensor values. At the end you then send a "BYESUD" closing message to stop communication and close down the USB handlers as appropriate.

At least this is what I think happens, so far I can get the welcome response back but not the sensor readings. The Seneye main.cpp module does work however as I got that working on Linux using much munging and CMake!